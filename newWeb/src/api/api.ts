/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Appointment
 */
export interface Appointment {
    /**
     * 
     * @type {number}
     * @memberof Appointment
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Appointment
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof Appointment
     */
    'time': string;
    /**
     * 
     * @type {AppointmentStatusEnum}
     * @memberof Appointment
     */
    'status'?: AppointmentStatusEnum;
    /**
     * 
     * @type {Service}
     * @memberof Appointment
     */
    'service_details': Service;
}


/**
 * 
 * @export
 * @interface AppointmentRequest
 */
export interface AppointmentRequest {
    /**
     * 
     * @type {number}
     * @memberof AppointmentRequest
     */
    'service': number;
    /**
     * 
     * @type {string}
     * @memberof AppointmentRequest
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof AppointmentRequest
     */
    'time': string;
    /**
     * 
     * @type {AppointmentStatusEnum}
     * @memberof AppointmentRequest
     */
    'status'?: AppointmentStatusEnum;
}


/**
 * * `Scheduled` - Scheduled * `Completed` - Completed * `Cancelled` - Cancelled
 * @export
 * @enum {string}
 */

export const AppointmentStatusEnum = {
    Scheduled: 'Scheduled',
    Completed: 'Completed',
    Cancelled: 'Cancelled'
} as const;

export type AppointmentStatusEnum = typeof AppointmentStatusEnum[keyof typeof AppointmentStatusEnum];


/**
 * 
 * @export
 * @interface Car
 */
export interface Car {
    /**
     * 
     * @type {number}
     * @memberof Car
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Car
     */
    'customer_details': Customer;
    /**
     * 
     * @type {PredefinedCar}
     * @memberof Car
     */
    'predefined_car': PredefinedCar;
    /**
     * 
     * @type {string}
     * @memberof Car
     */
    'reg_no': string;
    /**
     * 
     * @type {boolean}
     * @memberof Car
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Car
     */
    'is_available'?: boolean;
}
/**
 * 
 * @export
 * @interface CarHealth
 */
export interface CarHealth {
    /**
     * 
     * @type {number}
     * @memberof CarHealth
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CarHealth
     */
    'odometer': number;
    /**
     * 
     * @type {number}
     * @memberof CarHealth
     */
    'battery': number;
    /**
     * 
     * @type {number}
     * @memberof CarHealth
     */
    'tires': number;
    /**
     * 
     * @type {number}
     * @memberof CarHealth
     */
    'oilLevel': number;
    /**
     * 
     * @type {number}
     * @memberof CarHealth
     */
    'brakePads': number;
    /**
     * 
     * @type {number}
     * @memberof CarHealth
     */
    'airFilter': number;
    /**
     * 
     * @type {string}
     * @memberof CarHealth
     */
    'last_updated'?: string;
}
/**
 * 
 * @export
 * @interface CarHealthRequest
 */
export interface CarHealthRequest {
    /**
     * 
     * @type {number}
     * @memberof CarHealthRequest
     */
    'car': number;
    /**
     * 
     * @type {number}
     * @memberof CarHealthRequest
     */
    'odometer': number;
    /**
     * 
     * @type {number}
     * @memberof CarHealthRequest
     */
    'battery': number;
    /**
     * 
     * @type {number}
     * @memberof CarHealthRequest
     */
    'tires': number;
    /**
     * 
     * @type {number}
     * @memberof CarHealthRequest
     */
    'oilLevel': number;
    /**
     * 
     * @type {number}
     * @memberof CarHealthRequest
     */
    'brakePads': number;
    /**
     * 
     * @type {number}
     * @memberof CarHealthRequest
     */
    'airFilter': number;
    /**
     * 
     * @type {string}
     * @memberof CarHealthRequest
     */
    'last_updated'?: string;
}
/**
 * 
 * @export
 * @interface CarRequest
 */
export interface CarRequest {
    /**
     * 
     * @type {number}
     * @memberof CarRequest
     */
    'customer_id': number;
    /**
     * 
     * @type {number}
     * @memberof CarRequest
     */
    'predefined_car_id': number;
    /**
     * 
     * @type {string}
     * @memberof CarRequest
     */
    'reg_no': string;
    /**
     * 
     * @type {boolean}
     * @memberof CarRequest
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CarRequest
     */
    'is_available'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateAppointment
 */
export interface CreateAppointment {
    /**
     * 
     * @type {number}
     * @memberof CreateAppointment
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CreateAppointment
     */
    'service': number;
    /**
     * 
     * @type {string}
     * @memberof CreateAppointment
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAppointment
     */
    'time': string;
}
/**
 * 
 * @export
 * @interface CreateAppointmentRequest
 */
export interface CreateAppointmentRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateAppointmentRequest
     */
    'service': number;
    /**
     * 
     * @type {string}
     * @memberof CreateAppointmentRequest
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAppointmentRequest
     */
    'time': string;
}
/**
 * 
 * @export
 * @interface CreateService
 */
export interface CreateService {
    /**
     * 
     * @type {number}
     * @memberof CreateService
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CreateService
     */
    'car': number;
    /**
     * 
     * @type {string}
     * @memberof CreateService
     */
    'date': string;
}
/**
 * 
 * @export
 * @interface CreateServiceRequest
 */
export interface CreateServiceRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateServiceRequest
     */
    'car': number;
    /**
     * 
     * @type {number}
     * @memberof CreateServiceRequest
     */
    'service_type': number;
    /**
     * 
     * @type {string}
     * @memberof CreateServiceRequest
     */
    'date': string;
}
/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {User}
     * @memberof Customer
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface CustomerRequest
 */
export interface CustomerRequest {
    /**
     * 
     * @type {UserRequest}
     * @memberof CustomerRequest
     */
    'user': UserRequest;
    /**
     * 
     * @type {string}
     * @memberof CustomerRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'discount': string;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'id': number;
    /**
     * 
     * @type {Service}
     * @memberof Invoice
     */
    'service': Service;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'labor_fees': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'tax': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'total_amount': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'status'?: string;
    /**
     * 
     * @type {Array<PartInvoice>}
     * @memberof Invoice
     */
    'part_invoices': Array<PartInvoice>;

}
/**
 * 
 * @export
 * @interface InvoiceRequest
 */
export interface InvoiceRequest {
    /**
     * 
     * @type {string}
     * @memberof InvoiceRequest
     */
    'labor_fees': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceRequest
     */
    'tax': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceRequest
     */
    'total_amount': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceRequest
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Manager
 */
export interface Manager {
    /**
     * 
     * @type {User}
     * @memberof Manager
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface ManagerRequest
 */
export interface ManagerRequest {
    /**
     * 
     * @type {UserRequest}
     * @memberof ManagerRequest
     */
    'user': UserRequest;
    /**
     * 
     * @type {string}
     * @memberof ManagerRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface Mechanic
 */
export interface Mechanic {
    /**
     * 
     * @type {User}
     * @memberof Mechanic
     */
    'user': User;
    /**
     * 
     * @type {boolean}
     * @memberof Mechanic
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Mechanic
     */
    'current_workload'?: number;
}
/**
 * 
 * @export
 * @interface MechanicRequest
 */
export interface MechanicRequest {
    /**
     * 
     * @type {UserRequest}
     * @memberof MechanicRequest
     */
    'user': UserRequest;
    /**
     * 
     * @type {string}
     * @memberof MechanicRequest
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MechanicRequest
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MechanicRequest
     */
    'current_workload'?: number;
}
/**
 * 
 * @export
 * @interface Part
 */
export interface Part {
    /**
     * 
     * @type {number}
     * @memberof Part
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Part
     */
    'predefined_part': number;
    /**
     * 
     * @type {string}
     * @memberof Part
     */
    'predefined_part_name': string;
    /**
     * 
     * @type {string}
     * @memberof Part
     */
    'predefined_part_description': string;
    /**
     * 
     * @type {string}
     * @memberof Part
     */
    'price': string;
}
/**
 * 
 * @export
 * @interface PartInvoice
 */
export interface PartInvoice {
    /**
     * 
     * @type {number}
     * @memberof PartInvoice
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PartInvoice
     */
    'part': number;
    /**
     * 
     * @type {number}
     * @memberof PartInvoice
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartInvoice
     */
    'price': string;
}
/**
 * 
 * @export
 * @interface PartInvoiceRequest
 */
export interface PartInvoiceRequest {
    /**
 * 
 * @type {number}
 * @memberof PartInvoice
 */
    'part': PredefinedPart;
    /**
     * 
     * @type {number}
     * @memberof PartInvoiceRequest
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartInvoiceRequest
     */
    'price': string;
}
/**
 * 
 * @export
 * @interface PartRequest
 */
export interface PartRequest {
    /**
     * 
     * @type {number}
     * @memberof PartRequest
     */
    'predefined_car': number;
    /**
     * 
     * @type {number}
     * @memberof PartRequest
     */
    'predefined_part': number;
    /**
     * 
     * @type {string}
     * @memberof PartRequest
     */
    'price': string;
}
/**
 * 
 * @export
 * @interface PatchedAppointmentRequest
 */
export interface PatchedAppointmentRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedAppointmentRequest
     */
    'service'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedAppointmentRequest
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAppointmentRequest
     */
    'time'?: string;
    /**
     * 
     * @type {AppointmentStatusEnum}
     * @memberof PatchedAppointmentRequest
     */
    'status'?: AppointmentStatusEnum;
}


/**
 * 
 * @export
 * @interface PatchedCarHealthRequest
 */
export interface PatchedCarHealthRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedCarHealthRequest
     */
    'car'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedCarHealthRequest
     */
    'odometer'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedCarHealthRequest
     */
    'battery'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedCarHealthRequest
     */
    'tires'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedCarHealthRequest
     */
    'oilLevel'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedCarHealthRequest
     */
    'brakePads'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedCarHealthRequest
     */
    'airFilter'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedCarHealthRequest
     */
    'last_updated'?: string;
}
/**
 * 
 * @export
 * @interface PatchedCustomerRequest
 */
export interface PatchedCustomerRequest {
    /**
     * 
     * @type {UserRequest}
     * @memberof PatchedCustomerRequest
     */
    'user'?: UserRequest;
    /**
     * 
     * @type {string}
     * @memberof PatchedCustomerRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface PatchedInvoiceRequest
 */
export interface PatchedInvoiceRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedInvoiceRequest
     */
    'labor_fees'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedInvoiceRequest
     */
    'tax'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedInvoiceRequest
     */
    'total_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedInvoiceRequest
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface PatchedManagerRequest
 */
export interface PatchedManagerRequest {
    /**
     * 
     * @type {UserRequest}
     * @memberof PatchedManagerRequest
     */
    'user'?: UserRequest;
    /**
     * 
     * @type {string}
     * @memberof PatchedManagerRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface PatchedMechanicRequest
 */
export interface PatchedMechanicRequest {
    /**
     * 
     * @type {UserRequest}
     * @memberof PatchedMechanicRequest
     */
    'user'?: UserRequest;
    /**
     * 
     * @type {string}
     * @memberof PatchedMechanicRequest
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedMechanicRequest
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedMechanicRequest
     */
    'current_workload'?: number;
}
/**
 * 
 * @export
 * @interface PatchedPredefinedCarRequest
 */
export interface PatchedPredefinedCarRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedPredefinedCarRequest
     */
    'make'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPredefinedCarRequest
     */
    'model'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedPredefinedCarRequest
     */
    'year'?: number;
    /**
     * 
     * @type {File}
     * @memberof PatchedPredefinedCarRequest
     */
    'image'?: File | null;
}
/**
 * 
 * @export
 * @interface PatchedServiceRequest
 */
export interface PatchedServiceRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceRequest
     */
    'car_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceRequest
     */
    'service'?: number;
    /**
     * 
     * @type {StatusC3aEnum}
     * @memberof PatchedServiceRequest
     */
    'status'?: StatusC3aEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceRequest
     */
    'date'?: string;
}


/**
 * 
 * @export
 * @interface PatchedServiceTypeRequest
 */
export interface PatchedServiceTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceTypeRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceTypeRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<PredefinedTaskRequest>}
     * @memberof PatchedServiceTypeRequest
     */
    'predefined_tasks'?: Array<PredefinedTaskRequest>;
    /**
     * 
     * @type {Array<PredefinedPartRequest>}
     * @memberof PatchedServiceTypeRequest
     */
    'predefined_parts'?: Array<PredefinedPartRequest>;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceTypeRequest
     */
    'labour_cost'?: string;
}
/**
 * 
 * @export
 * @interface PatchedSkillRequest
 */
export interface PatchedSkillRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedSkillRequest
     */
    'vehicle_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSkillRequest
     */
    'vehicle_part'?: string;
    /**
     * 
     * @type {any}
     * @memberof PatchedSkillRequest
     */
    'steps'?: any;
}
/**
 * 
 * @export
 * @interface PatchedTaskRequest
 */
export interface PatchedTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedTaskRequest
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedTaskRequest
     */
    'assigned_to_id'?: number;
    /**
     * 
     * @type {TaskStatusEnum}
     * @memberof PatchedTaskRequest
     */
    'status'?: TaskStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof PatchedTaskRequest
     */
    'service_type'?: number;
}


/**
 * 
 * @export
 * @interface PatchedUpdateQuoteStatusRequest
 */
export interface PatchedUpdateQuoteStatusRequest {
    /**
     * 
     * @type {Status553Enum}
     * @memberof PatchedUpdateQuoteStatusRequest
     */
    'status'?: Status553Enum;
}


/**
 * 
 * @export
 * @interface PredefinedCar
 */
export interface PredefinedCar {
    /**
     * 
     * @type {number}
     * @memberof PredefinedCar
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PredefinedCar
     */
    'make': string;
    /**
     * 
     * @type {string}
     * @memberof PredefinedCar
     */
    'model': string;
    /**
     * 
     * @type {number}
     * @memberof PredefinedCar
     */
    'year': number;
    /**
     * 
     * @type {string}
     * @memberof PredefinedCar
     */
    'image'?: string | null;
}
/**
 * 
 * @export
 * @interface PredefinedCarRequest
 */
export interface PredefinedCarRequest {
    /**
     * 
     * @type {string}
     * @memberof PredefinedCarRequest
     */
    'make': string;
    /**
     * 
     * @type {string}
     * @memberof PredefinedCarRequest
     */
    'model': string;
    /**
     * 
     * @type {number}
     * @memberof PredefinedCarRequest
     */
    'year': number;
    /**
     * 
     * @type {File}
     * @memberof PredefinedCarRequest
     */
    'image'?: File | null;
}
/**
 * 
 * @export
 * @interface PredefinedPart
 */
export interface PredefinedPart {
    /**
     * 
     * @type {number}
     * @memberof PredefinedPart
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PredefinedPart
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PredefinedPart
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface PredefinedPartRequest
 */
export interface PredefinedPartRequest {
    /**
     * 
     * @type {string}
     * @memberof PredefinedPartRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PredefinedPartRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface PredefinedTask
 */
export interface PredefinedTask {
    /**
     * 
     * @type {number}
     * @memberof PredefinedTask
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PredefinedTask
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface PredefinedTaskRequest
 */
export interface PredefinedTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof PredefinedTaskRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface Quote
 */
export interface Quote {
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    'id': number;
    /**
     * 
     * @type {Service}
     * @memberof Quote
     */
    'service': Service;
    /**
     * 
     * @type {Car}
     * @memberof Quote
     */
    'car': Car;
    /**
     * 
     * @type {Array<QuotePart>}
     * @memberof Quote
     */
    'parts': Array<QuotePart>;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'labor_fees': string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'tax': string;
    /**
     * 
     * @type {Status553Enum}
     * @memberof Quote
     */
    'status'?: Status553Enum;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'total_price': string;
}


/**
 * 
 * @export
 * @interface QuotePart
 */
export interface QuotePart {
    /**
     * 
     * @type {number}
     * @memberof QuotePart
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof QuotePart
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuotePart
     */
    'price': string;
}
/**
 * * `Customer` - Customer * `Mechanic` - Mechanic * `Manager` - Manager
 * @export
 * @enum {string}
 */

export const RoleEnum = {
    Customer: 'Customer',
    Mechanic: 'Mechanic',
    Manager: 'Manager'
} as const;

export type RoleEnum = typeof RoleEnum[keyof typeof RoleEnum];


/**
 * 
 * @export
 * @interface Service
 */
export interface Service {
    /**
     * 
     * @type {number}
     * @memberof Service
     */
    'id': number;
    /**
     * 
     * @type {Car}
     * @memberof Service
     */
    'car': Car;
    /**
     * 
     * @type {ServiceType}
     * @memberof Service
     */
    'service_type': ServiceType;
    /**
     * 
     * @type {StatusC3aEnum}
     * @memberof Service
     */
    'status'?: StatusC3aEnum;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    'date': string;
    /**
     * 
     * @type {Array<Task>}
     * @memberof Service
     */
    'tasks': Array<Task>;
}


/**
 * 
 * @export
 * @interface ServiceRequest
 */
export interface ServiceRequest {
    /**
     * 
     * @type {number}
     * @memberof ServiceRequest
     */
    'car_id': number;
    /**
     * 
     * @type {number}
     * @memberof ServiceRequest
     */
    'service': number;
    /**
     * 
     * @type {StatusC3aEnum}
     * @memberof ServiceRequest
     */
    'status'?: StatusC3aEnum;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequest
     */
    'date': string;
}


/**
 * 
 * @export
 * @interface ServiceSerializers
 */
export interface ServiceSerializers {
    /**
     * 
     * @type {number}
     * @memberof ServiceSerializers
     */
    'id': number;
    /**
     * 
     * @type {Car}
     * @memberof ServiceSerializers
     */
    'car': Car;
    /**
     * 
     * @type {ServiceType}
     * @memberof ServiceSerializers
     */
    'service_type': ServiceType;
    /**
     * 
     * @type {StatusC3aEnum}
     * @memberof ServiceSerializers
     */
    'status'?: StatusC3aEnum;
    /**
     * 
     * @type {string}
     * @memberof ServiceSerializers
     */
    'date': string;
}


/**
 * 
 * @export
 * @interface ServiceSerializersRequest
 */
export interface ServiceSerializersRequest {
    /**
     * 
     * @type {number}
     * @memberof ServiceSerializersRequest
     */
    'car_id': number;
    /**
     * 
     * @type {number}
     * @memberof ServiceSerializersRequest
     */
    'service': number;
    /**
     * 
     * @type {StatusC3aEnum}
     * @memberof ServiceSerializersRequest
     */
    'status'?: StatusC3aEnum;
    /**
     * 
     * @type {string}
     * @memberof ServiceSerializersRequest
     */
    'date': string;
}


/**
 * 
 * @export
 * @interface ServiceType
 */
export interface ServiceType {
    /**
     * 
     * @type {number}
     * @memberof ServiceType
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceType
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceType
     */
    'description': string;
    /**
     * 
     * @type {Array<PredefinedTask>}
     * @memberof ServiceType
     */
    'predefined_tasks': Array<PredefinedTask>;
    /**
     * 
     * @type {Array<PredefinedPart>}
     * @memberof ServiceType
     */
    'predefined_parts': Array<PredefinedPart>;
    /**
     * 
     * @type {string}
     * @memberof ServiceType
     */
    'labour_cost'?: string;
}
/**
 * 
 * @export
 * @interface ServiceTypeRequest
 */
export interface ServiceTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof ServiceTypeRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceTypeRequest
     */
    'description': string;
    /**
     * 
     * @type {Array<PredefinedTaskRequest>}
     * @memberof ServiceTypeRequest
     */
    'predefined_tasks': Array<PredefinedTaskRequest>;
    /**
     * 
     * @type {Array<PredefinedPartRequest>}
     * @memberof ServiceTypeRequest
     */
    'predefined_parts': Array<PredefinedPartRequest>;
    /**
     * 
     * @type {string}
     * @memberof ServiceTypeRequest
     */
    'labour_cost'?: string;
}
/**
 * 
 * @export
 * @interface Skill
 */
export interface Skill {
    /**
     * 
     * @type {number}
     * @memberof Skill
     */
    'id': number;
    /**
     * 
     * @type {PredefinedCar}
     * @memberof Skill
     */
    'vehicle': PredefinedCar;
    /**
     * 
     * @type {string}
     * @memberof Skill
     */
    'vehicle_part': string;
    /**
     * 
     * @type {any}
     * @memberof Skill
     */
    'steps': any;
}
/**
 * 
 * @export
 * @interface SkillRequest
 */
export interface SkillRequest {
    /**
     * 
     * @type {number}
     * @memberof SkillRequest
     */
    'vehicle_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SkillRequest
     */
    'vehicle_part': string;
    /**
     * 
     * @type {any}
     * @memberof SkillRequest
     */
    'steps': any;
}
/**
 * * `Pending` - Pending * `Accepted` - Accepted * `Declined` - Declined
 * @export
 * @enum {string}
 */

export const Status553Enum = {
    Pending: 'Pending',
    Accepted: 'Accepted',
    Declined: 'Declined'
} as const;

export type Status553Enum = typeof Status553Enum[keyof typeof Status553Enum];


/**
 * * `Requested` - Requested * `In Progress` - In Progress * `Completed` - Completed * `Canceled` - Canceled
 * @export
 * @enum {string}
 */

export const StatusC3aEnum = {
    Requested: 'Requested',
    InProgress: 'In Progress',
    Completed: 'Completed',
    Canceled: 'Canceled'
} as const;

export type StatusC3aEnum = typeof StatusC3aEnum[keyof typeof StatusC3aEnum];


/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'id': number;
    /**
     * 
     * @type {ServiceSerializers}
     * @memberof Task
     */
    'service': ServiceSerializers;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'description': string;
    /**
     * 
     * @type {Mechanic}
     * @memberof Task
     */
    'assigned_to': Mechanic;
    /**
     * 
     * @type {TaskStatusEnum}
     * @memberof Task
     */
    'status'?: TaskStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'service_type': number;
}


/**
 * 
 * @export
 * @interface TaskRequest
 */
export interface TaskRequest {
    /**
     * 
     * @type {string}
     * @memberof TaskRequest
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof TaskRequest
     */
    'assigned_to_id': number;
    /**
     * 
     * @type {TaskStatusEnum}
     * @memberof TaskRequest
     */
    'status'?: TaskStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof TaskRequest
     */
    'service_type': number;
}


/**
 * * `Pending` - Pending * `Completed` - Completed
 * @export
 * @enum {string}
 */

export const TaskStatusEnum = {
    Pending: 'Pending',
    Completed: 'Completed',
    InProgress: "In Progress"
} as const;

export type TaskStatusEnum = typeof TaskStatusEnum[keyof typeof TaskStatusEnum];


/**
 * 
 * @export
 * @interface UpdateQuoteStatus
 */
export interface UpdateQuoteStatus {
    /**
     * 
     * @type {number}
     * @memberof UpdateQuoteStatus
     */
    'id': number;
    /**
     * 
     * @type {Status553Enum}
     * @memberof UpdateQuoteStatus
     */
    'status'?: Status553Enum;
    /**
     * 
     * @type {number}
     * @memberof UpdateQuoteStatus
     */
    'service': number;
}


/**
 * 
 * @export
 * @interface UpdateQuoteStatusRequest
 */
export interface UpdateQuoteStatusRequest {
    /**
     * 
     * @type {Status553Enum}
     * @memberof UpdateQuoteStatusRequest
     */
    'status'?: Status553Enum;
}


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'surname': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'street_address': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'postal_code': string;
    /**
     * 
     * @type {RoleEnum}
     * @memberof User
     */
    'role': RoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_active': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at': string;
}


/**
 * 
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'surname': string;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'street_address': string;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'postal_code': string;
}

/**
 * AppointmentApi - axios parameter creator
 * @export
 */
export const AppointmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {PatchedAppointmentRequest} [patchedAppointmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appointmentsAppointmentsUpdatePartialUpdate: async (id: number, patchedAppointmentRequest?: PatchedAppointmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appointmentsAppointmentsUpdatePartialUpdate', 'id', id)
            const localVarPath = `/api/appointments/appointments/update/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAppointmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {AppointmentRequest} appointmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appointmentsAppointmentsUpdateUpdate: async (id: number, appointmentRequest: AppointmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appointmentsAppointmentsUpdateUpdate', 'id', id)
            // verify required parameter 'appointmentRequest' is not null or undefined
            assertParamExists('appointmentsAppointmentsUpdateUpdate', 'appointmentRequest', appointmentRequest)
            const localVarPath = `/api/appointments/appointments/update/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(appointmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dateStr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appointmentsAvailableSlotsRetrieve: async (dateStr: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dateStr' is not null or undefined
            assertParamExists('appointmentsAvailableSlotsRetrieve', 'dateStr', dateStr)
            const localVarPath = `/api/appointments/available-slots/{date_str}/`
                .replace(`{${"date_str"}}`, encodeURIComponent(String(dateStr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateAppointmentRequest} createAppointmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appointmentsCreateCreate: async (createAppointmentRequest: CreateAppointmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAppointmentRequest' is not null or undefined
            assertParamExists('appointmentsCreateCreate', 'createAppointmentRequest', createAppointmentRequest)
            const localVarPath = `/api/appointments/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createAppointmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appointmentsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/appointments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appointmentsUserList: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('appointmentsUserList', 'userId', userId)
            const localVarPath = `/api/appointments/user/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppointmentApi - functional programming interface
 * @export
 */
export const AppointmentApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AppointmentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {PatchedAppointmentRequest} [patchedAppointmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appointmentsAppointmentsUpdatePartialUpdate(id: number, patchedAppointmentRequest?: PatchedAppointmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appointmentsAppointmentsUpdatePartialUpdate(id, patchedAppointmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentApi.appointmentsAppointmentsUpdatePartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {AppointmentRequest} appointmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appointmentsAppointmentsUpdateUpdate(id: number, appointmentRequest: AppointmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appointmentsAppointmentsUpdateUpdate(id, appointmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentApi.appointmentsAppointmentsUpdateUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} dateStr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appointmentsAvailableSlotsRetrieve(dateStr: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appointmentsAvailableSlotsRetrieve(dateStr, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentApi.appointmentsAvailableSlotsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateAppointmentRequest} createAppointmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appointmentsCreateCreate(createAppointmentRequest: CreateAppointmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAppointment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appointmentsCreateCreate(createAppointmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentApi.appointmentsCreateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appointmentsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Appointment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appointmentsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentApi.appointmentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appointmentsUserList(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Appointment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appointmentsUserList(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentApi.appointmentsUserList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppointmentApi - factory interface
 * @export
 */
export const AppointmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppointmentApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {PatchedAppointmentRequest} [patchedAppointmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appointmentsAppointmentsUpdatePartialUpdate(id: number, patchedAppointmentRequest?: PatchedAppointmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Appointment> {
            return localVarFp.appointmentsAppointmentsUpdatePartialUpdate(id, patchedAppointmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {AppointmentRequest} appointmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appointmentsAppointmentsUpdateUpdate(id: number, appointmentRequest: AppointmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Appointment> {
            return localVarFp.appointmentsAppointmentsUpdateUpdate(id, appointmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} dateStr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appointmentsAvailableSlotsRetrieve(dateStr: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appointmentsAvailableSlotsRetrieve(dateStr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateAppointmentRequest} createAppointmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appointmentsCreateCreate(createAppointmentRequest: CreateAppointmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAppointment> {
            return localVarFp.appointmentsCreateCreate(createAppointmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appointmentsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Appointment>> {
            return localVarFp.appointmentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appointmentsUserList(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Appointment>> {
            return localVarFp.appointmentsUserList(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppointmentApi - object-oriented interface
 * @export
 * @class AppointmentApi
 * @extends {BaseAPI}
 */
export class AppointmentApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {PatchedAppointmentRequest} [patchedAppointmentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentApi
     */
    public appointmentsAppointmentsUpdatePartialUpdate(id: number, patchedAppointmentRequest?: PatchedAppointmentRequest, options?: RawAxiosRequestConfig) {
        return AppointmentApiFp(this.configuration).appointmentsAppointmentsUpdatePartialUpdate(id, patchedAppointmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {AppointmentRequest} appointmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentApi
     */
    public appointmentsAppointmentsUpdateUpdate(id: number, appointmentRequest: AppointmentRequest, options?: RawAxiosRequestConfig) {
        return AppointmentApiFp(this.configuration).appointmentsAppointmentsUpdateUpdate(id, appointmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} dateStr 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentApi
     */
    public appointmentsAvailableSlotsRetrieve(dateStr: string, options?: RawAxiosRequestConfig) {
        return AppointmentApiFp(this.configuration).appointmentsAvailableSlotsRetrieve(dateStr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateAppointmentRequest} createAppointmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentApi
     */
    public appointmentsCreateCreate(createAppointmentRequest: CreateAppointmentRequest, options?: RawAxiosRequestConfig) {
        return AppointmentApiFp(this.configuration).appointmentsCreateCreate(createAppointmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentApi
     */
    public appointmentsList(options?: RawAxiosRequestConfig) {
        return AppointmentApiFp(this.configuration).appointmentsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentApi
     */
    public appointmentsUserList(userId: number, options?: RawAxiosRequestConfig) {
        return AppointmentApiFp(this.configuration).appointmentsUserList(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CarApi - axios parameter creator
 * @export
 */
export const CarApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsAllCarsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cars/all_cars/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsMakesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cars/makes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} make 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsMakesModelsRetrieve: async (make: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'make' is not null or undefined
            assertParamExists('carsMakesModelsRetrieve', 'make', make)
            const localVarPath = `/api/cars/makes/{make}/models/`
                .replace(`{${"make"}}`, encodeURIComponent(String(make)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} make 
         * @param {string} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsMakesModelsYearsRetrieve: async (make: string, model: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'make' is not null or undefined
            assertParamExists('carsMakesModelsYearsRetrieve', 'make', make)
            // verify required parameter 'model' is not null or undefined
            assertParamExists('carsMakesModelsYearsRetrieve', 'model', model)
            const localVarPath = `/api/cars/makes/{make}/models/{model}/years/`
                .replace(`{${"make"}}`, encodeURIComponent(String(make)))
                .replace(`{${"model"}}`, encodeURIComponent(String(model)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PredefinedCarRequest} predefinedCarRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsPredefinedCarsAddCreate: async (predefinedCarRequest: PredefinedCarRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'predefinedCarRequest' is not null or undefined
            assertParamExists('carsPredefinedCarsAddCreate', 'predefinedCarRequest', predefinedCarRequest)
            const localVarPath = `/api/cars/predefined_cars/add/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(predefinedCarRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedPredefinedCarRequest} [patchedPredefinedCarRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsPredefinedCarsEditPartialUpdate: async (id: number, patchedPredefinedCarRequest?: PatchedPredefinedCarRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('carsPredefinedCarsEditPartialUpdate', 'id', id)
            const localVarPath = `/api/cars/predefined_cars/edit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPredefinedCarRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PredefinedCarRequest} predefinedCarRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsPredefinedCarsEditUpdate: async (id: number, predefinedCarRequest: PredefinedCarRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('carsPredefinedCarsEditUpdate', 'id', id)
            // verify required parameter 'predefinedCarRequest' is not null or undefined
            assertParamExists('carsPredefinedCarsEditUpdate', 'predefinedCarRequest', predefinedCarRequest)
            const localVarPath = `/api/cars/predefined_cars/edit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(predefinedCarRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsPredefinedCarsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cars/predefined_cars/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CarRequest} carRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsRegisterCreate: async (carRequest: CarRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carRequest' is not null or undefined
            assertParamExists('carsRegisterCreate', 'carRequest', carRequest)
            const localVarPath = `/api/cars/register/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(carRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} carId 
         * @param {number} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsUserCarsSetDefaultPartialUpdate: async (carId: number, customerId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('carsUserCarsSetDefaultPartialUpdate', 'carId', carId)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('carsUserCarsSetDefaultPartialUpdate', 'customerId', customerId)
            const localVarPath = `/api/cars/user/{customer_id}/cars/{car_id}/set-default/`
                .replace(`{${"car_id"}}`, encodeURIComponent(String(carId)))
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} carId 
         * @param {number} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsUserCarsSetDefaultRetrieve: async (carId: number, customerId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('carsUserCarsSetDefaultRetrieve', 'carId', carId)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('carsUserCarsSetDefaultRetrieve', 'customerId', customerId)
            const localVarPath = `/api/cars/user/{customer_id}/cars/{car_id}/set-default/`
                .replace(`{${"car_id"}}`, encodeURIComponent(String(carId)))
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsUserDefaultCarRetrieve: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('carsUserDefaultCarRetrieve', 'userId', userId)
            const localVarPath = `/api/cars/user/{user_id}/default_car/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsUsersCarsRetrieve: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('carsUsersCarsRetrieve', 'userId', userId)
            const localVarPath = `/api/cars/users/{user_id}/cars/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CarApi - functional programming interface
 * @export
 */
export const CarApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CarApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsAllCarsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Car>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsAllCarsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsAllCarsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsMakesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PredefinedCar>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsMakesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsMakesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} make 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsMakesModelsRetrieve(make: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsMakesModelsRetrieve(make, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsMakesModelsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} make 
         * @param {string} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsMakesModelsYearsRetrieve(make: string, model: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsMakesModelsYearsRetrieve(make, model, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsMakesModelsYearsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PredefinedCarRequest} predefinedCarRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsPredefinedCarsAddCreate(predefinedCarRequest: PredefinedCarRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PredefinedCar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsPredefinedCarsAddCreate(predefinedCarRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsPredefinedCarsAddCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedPredefinedCarRequest} [patchedPredefinedCarRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsPredefinedCarsEditPartialUpdate(id: number, patchedPredefinedCarRequest?: PatchedPredefinedCarRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PredefinedCar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsPredefinedCarsEditPartialUpdate(id, patchedPredefinedCarRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsPredefinedCarsEditPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {PredefinedCarRequest} predefinedCarRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsPredefinedCarsEditUpdate(id: number, predefinedCarRequest: PredefinedCarRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PredefinedCar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsPredefinedCarsEditUpdate(id, predefinedCarRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsPredefinedCarsEditUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsPredefinedCarsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PredefinedCar>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsPredefinedCarsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsPredefinedCarsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CarRequest} carRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsRegisterCreate(carRequest: CarRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Car>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsRegisterCreate(carRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsRegisterCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} carId 
         * @param {number} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsUserCarsSetDefaultPartialUpdate(carId: number, customerId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsUserCarsSetDefaultPartialUpdate(carId, customerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsUserCarsSetDefaultPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} carId 
         * @param {number} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsUserCarsSetDefaultRetrieve(carId: number, customerId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsUserCarsSetDefaultRetrieve(carId, customerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsUserCarsSetDefaultRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsUserDefaultCarRetrieve(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Car>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsUserDefaultCarRetrieve(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsUserDefaultCarRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carsUsersCarsRetrieve(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carsUsersCarsRetrieve(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarApi.carsUsersCarsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CarApi - factory interface
 * @export
 */
export const CarApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CarApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsAllCarsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Car>> {
            return localVarFp.carsAllCarsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsMakesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<PredefinedCar>> {
            return localVarFp.carsMakesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} make 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsMakesModelsRetrieve(make: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.carsMakesModelsRetrieve(make, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} make 
         * @param {string} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsMakesModelsYearsRetrieve(make: string, model: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.carsMakesModelsYearsRetrieve(make, model, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PredefinedCarRequest} predefinedCarRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsPredefinedCarsAddCreate(predefinedCarRequest: PredefinedCarRequest, options?: RawAxiosRequestConfig): AxiosPromise<PredefinedCar> {
            return localVarFp.carsPredefinedCarsAddCreate(predefinedCarRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedPredefinedCarRequest} [patchedPredefinedCarRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsPredefinedCarsEditPartialUpdate(id: number, patchedPredefinedCarRequest?: PatchedPredefinedCarRequest, options?: RawAxiosRequestConfig): AxiosPromise<PredefinedCar> {
            return localVarFp.carsPredefinedCarsEditPartialUpdate(id, patchedPredefinedCarRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PredefinedCarRequest} predefinedCarRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsPredefinedCarsEditUpdate(id: number, predefinedCarRequest: PredefinedCarRequest, options?: RawAxiosRequestConfig): AxiosPromise<PredefinedCar> {
            return localVarFp.carsPredefinedCarsEditUpdate(id, predefinedCarRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsPredefinedCarsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<PredefinedCar>> {
            return localVarFp.carsPredefinedCarsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CarRequest} carRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsRegisterCreate(carRequest: CarRequest, options?: RawAxiosRequestConfig): AxiosPromise<Car> {
            return localVarFp.carsRegisterCreate(carRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} carId 
         * @param {number} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsUserCarsSetDefaultPartialUpdate(carId: number, customerId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.carsUserCarsSetDefaultPartialUpdate(carId, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} carId 
         * @param {number} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsUserCarsSetDefaultRetrieve(carId: number, customerId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.carsUserCarsSetDefaultRetrieve(carId, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsUserDefaultCarRetrieve(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Car> {
            return localVarFp.carsUserDefaultCarRetrieve(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carsUsersCarsRetrieve(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.carsUsersCarsRetrieve(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CarApi - object-oriented interface
 * @export
 * @class CarApi
 * @extends {BaseAPI}
 */
export class CarApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsAllCarsList(options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsAllCarsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsMakesList(options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsMakesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} make 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsMakesModelsRetrieve(make: string, options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsMakesModelsRetrieve(make, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} make 
     * @param {string} model 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsMakesModelsYearsRetrieve(make: string, model: string, options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsMakesModelsYearsRetrieve(make, model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PredefinedCarRequest} predefinedCarRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsPredefinedCarsAddCreate(predefinedCarRequest: PredefinedCarRequest, options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsPredefinedCarsAddCreate(predefinedCarRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {PatchedPredefinedCarRequest} [patchedPredefinedCarRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsPredefinedCarsEditPartialUpdate(id: number, patchedPredefinedCarRequest?: PatchedPredefinedCarRequest, options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsPredefinedCarsEditPartialUpdate(id, patchedPredefinedCarRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {PredefinedCarRequest} predefinedCarRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsPredefinedCarsEditUpdate(id: number, predefinedCarRequest: PredefinedCarRequest, options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsPredefinedCarsEditUpdate(id, predefinedCarRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsPredefinedCarsList(options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsPredefinedCarsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CarRequest} carRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsRegisterCreate(carRequest: CarRequest, options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsRegisterCreate(carRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} carId 
     * @param {number} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsUserCarsSetDefaultPartialUpdate(carId: number, customerId: number, options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsUserCarsSetDefaultPartialUpdate(carId, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} carId 
     * @param {number} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsUserCarsSetDefaultRetrieve(carId: number, customerId: number, options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsUserCarsSetDefaultRetrieve(carId, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsUserDefaultCarRetrieve(userId: number, options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsUserDefaultCarRetrieve(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarApi
     */
    public carsUsersCarsRetrieve(userId: number, options?: RawAxiosRequestConfig) {
        return CarApiFp(this.configuration).carsUsersCarsRetrieve(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CarHealthApi - axios parameter creator
 * @export
 */
export const CarHealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} carId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carhealthCarhealthRetrieve: async (carId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('carhealthCarhealthRetrieve', 'carId', carId)
            const localVarPath = `/api/carhealth/{car_id}/carhealth/`
                .replace(`{${"car_id"}}`, encodeURIComponent(String(carId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CarHealthRequest} carHealthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carhealthCreateCreate: async (carHealthRequest: CarHealthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carHealthRequest' is not null or undefined
            assertParamExists('carhealthCreateCreate', 'carHealthRequest', carHealthRequest)
            const localVarPath = `/api/carhealth/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(carHealthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedCarHealthRequest} [patchedCarHealthRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carhealthEditPartialUpdate: async (id: number, patchedCarHealthRequest?: PatchedCarHealthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('carhealthEditPartialUpdate', 'id', id)
            const localVarPath = `/api/carhealth/edit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCarHealthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CarHealthRequest} carHealthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carhealthEditUpdate: async (id: number, carHealthRequest: CarHealthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('carhealthEditUpdate', 'id', id)
            // verify required parameter 'carHealthRequest' is not null or undefined
            assertParamExists('carhealthEditUpdate', 'carHealthRequest', carHealthRequest)
            const localVarPath = `/api/carhealth/edit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(carHealthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carhealthList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/carhealth/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CarHealthApi - functional programming interface
 * @export
 */
export const CarHealthApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CarHealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} carId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carhealthCarhealthRetrieve(carId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carhealthCarhealthRetrieve(carId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarHealthApi.carhealthCarhealthRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CarHealthRequest} carHealthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carhealthCreateCreate(carHealthRequest: CarHealthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarHealth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carhealthCreateCreate(carHealthRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarHealthApi.carhealthCreateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedCarHealthRequest} [patchedCarHealthRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carhealthEditPartialUpdate(id: number, patchedCarHealthRequest?: PatchedCarHealthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarHealth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carhealthEditPartialUpdate(id, patchedCarHealthRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarHealthApi.carhealthEditPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {CarHealthRequest} carHealthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carhealthEditUpdate(id: number, carHealthRequest: CarHealthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarHealth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carhealthEditUpdate(id, carHealthRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarHealthApi.carhealthEditUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async carhealthList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CarHealth>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.carhealthList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarHealthApi.carhealthList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CarHealthApi - factory interface
 * @export
 */
export const CarHealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CarHealthApiFp(configuration)
    return {
        /**
         * 
         * @param {number} carId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carhealthCarhealthRetrieve(carId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.carhealthCarhealthRetrieve(carId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CarHealthRequest} carHealthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carhealthCreateCreate(carHealthRequest: CarHealthRequest, options?: RawAxiosRequestConfig): AxiosPromise<CarHealth> {
            return localVarFp.carhealthCreateCreate(carHealthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedCarHealthRequest} [patchedCarHealthRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carhealthEditPartialUpdate(id: number, patchedCarHealthRequest?: PatchedCarHealthRequest, options?: RawAxiosRequestConfig): AxiosPromise<CarHealth> {
            return localVarFp.carhealthEditPartialUpdate(id, patchedCarHealthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {CarHealthRequest} carHealthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carhealthEditUpdate(id: number, carHealthRequest: CarHealthRequest, options?: RawAxiosRequestConfig): AxiosPromise<CarHealth> {
            return localVarFp.carhealthEditUpdate(id, carHealthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        carhealthList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CarHealth>> {
            return localVarFp.carhealthList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CarHealthApi - object-oriented interface
 * @export
 * @class CarHealthApi
 * @extends {BaseAPI}
 */
export class CarHealthApi extends BaseAPI {
    /**
     * 
     * @param {number} carId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarHealthApi
     */
    public carhealthCarhealthRetrieve(carId: number, options?: RawAxiosRequestConfig) {
        return CarHealthApiFp(this.configuration).carhealthCarhealthRetrieve(carId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CarHealthRequest} carHealthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarHealthApi
     */
    public carhealthCreateCreate(carHealthRequest: CarHealthRequest, options?: RawAxiosRequestConfig) {
        return CarHealthApiFp(this.configuration).carhealthCreateCreate(carHealthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {PatchedCarHealthRequest} [patchedCarHealthRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarHealthApi
     */
    public carhealthEditPartialUpdate(id: number, patchedCarHealthRequest?: PatchedCarHealthRequest, options?: RawAxiosRequestConfig) {
        return CarHealthApiFp(this.configuration).carhealthEditPartialUpdate(id, patchedCarHealthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {CarHealthRequest} carHealthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarHealthApi
     */
    public carhealthEditUpdate(id: number, carHealthRequest: CarHealthRequest, options?: RawAxiosRequestConfig) {
        return CarHealthApiFp(this.configuration).carhealthEditUpdate(id, carHealthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarHealthApi
     */
    public carhealthList(options?: RawAxiosRequestConfig) {
        return CarHealthApiFp(this.configuration).carhealthList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomerApi - axios parameter creator
 * @export
 */
export const CustomerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CustomerRequest} customerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCustomerCreateCreate: async (customerRequest: CustomerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerRequest' is not null or undefined
            assertParamExists('usersCustomerCreateCreate', 'customerRequest', customerRequest)
            const localVarPath = `/api/users/customer/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(customerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCustomerDestroy: async (user: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersCustomerDestroy', 'user', user)
            const localVarPath = `/api/users/customer/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this customer.
         * @param {PatchedCustomerRequest} [patchedCustomerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCustomerPartialUpdate: async (user: number, patchedCustomerRequest?: PatchedCustomerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersCustomerPartialUpdate', 'user', user)
            const localVarPath = `/api/users/customer/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCustomerRetrieve: async (user: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersCustomerRetrieve', 'user', user)
            const localVarPath = `/api/users/customer/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this customer.
         * @param {CustomerRequest} customerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCustomerUpdate: async (user: number, customerRequest: CustomerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersCustomerUpdate', 'user', user)
            // verify required parameter 'customerRequest' is not null or undefined
            assertParamExists('usersCustomerUpdate', 'customerRequest', customerRequest)
            const localVarPath = `/api/users/customer/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(customerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCustomersList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CustomerRequest} customerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCustomerCreateCreate(customerRequest: CustomerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCustomerCreateCreate(customerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.usersCustomerCreateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} user A unique value identifying this customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCustomerDestroy(user: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCustomerDestroy(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.usersCustomerDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} user A unique value identifying this customer.
         * @param {PatchedCustomerRequest} [patchedCustomerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCustomerPartialUpdate(user: number, patchedCustomerRequest?: PatchedCustomerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCustomerPartialUpdate(user, patchedCustomerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.usersCustomerPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} user A unique value identifying this customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCustomerRetrieve(user: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCustomerRetrieve(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.usersCustomerRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} user A unique value identifying this customer.
         * @param {CustomerRequest} customerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCustomerUpdate(user: number, customerRequest: CustomerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCustomerUpdate(user, customerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.usersCustomerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCustomersList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Customer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCustomersList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.usersCustomersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerApiFp(configuration)
    return {
        /**
         * 
         * @param {CustomerRequest} customerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCustomerCreateCreate(customerRequest: CustomerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Customer> {
            return localVarFp.usersCustomerCreateCreate(customerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCustomerDestroy(user: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersCustomerDestroy(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this customer.
         * @param {PatchedCustomerRequest} [patchedCustomerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCustomerPartialUpdate(user: number, patchedCustomerRequest?: PatchedCustomerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Customer> {
            return localVarFp.usersCustomerPartialUpdate(user, patchedCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCustomerRetrieve(user: number, options?: RawAxiosRequestConfig): AxiosPromise<Customer> {
            return localVarFp.usersCustomerRetrieve(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this customer.
         * @param {CustomerRequest} customerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCustomerUpdate(user: number, customerRequest: CustomerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Customer> {
            return localVarFp.usersCustomerUpdate(user, customerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCustomersList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Customer>> {
            return localVarFp.usersCustomersList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI {
    /**
     * 
     * @param {CustomerRequest} customerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public usersCustomerCreateCreate(customerRequest: CustomerRequest, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).usersCustomerCreateCreate(customerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this customer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public usersCustomerDestroy(user: number, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).usersCustomerDestroy(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this customer.
     * @param {PatchedCustomerRequest} [patchedCustomerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public usersCustomerPartialUpdate(user: number, patchedCustomerRequest?: PatchedCustomerRequest, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).usersCustomerPartialUpdate(user, patchedCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this customer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public usersCustomerRetrieve(user: number, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).usersCustomerRetrieve(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this customer.
     * @param {CustomerRequest} customerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public usersCustomerUpdate(user: number, customerRequest: CustomerRequest, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).usersCustomerUpdate(user, customerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public usersCustomersList(options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).usersCustomersList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvoiceApi - axios parameter creator
 * @export
 */
export const InvoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesInvoicesList: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('invoicesInvoicesList', 'userId', userId)
            const localVarPath = `/api/invoices/{user_id}/invoices/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invoices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedInvoiceRequest} [patchedInvoiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesPartialUpdate: async (id: number, patchedInvoiceRequest?: PatchedInvoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('invoicesPartialUpdate', 'id', id)
            const localVarPath = `/api/invoices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(patchedInvoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('invoicesRetrieve', 'id', id)
            const localVarPath = `/api/invoices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesServiceInvoiceRetrieve: async (serviceId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('invoicesServiceInvoiceRetrieve', 'serviceId', serviceId)
            const localVarPath = `/api/invoices/service/{service_id}/invoice/`
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {InvoiceRequest} invoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesUpdate: async (id: number, invoiceRequest: InvoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('invoicesUpdate', 'id', id)
            // verify required parameter 'invoiceRequest' is not null or undefined
            assertParamExists('invoicesUpdate', 'invoiceRequest', invoiceRequest)
            const localVarPath = `/api/invoices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceApi - functional programming interface
 * @export
 */
export const InvoiceApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invoicesInvoicesList(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoicesInvoicesList(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceApi.invoicesInvoicesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invoicesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoicesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceApi.invoicesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedInvoiceRequest} [patchedInvoiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invoicesPartialUpdate(id: number, patchedInvoiceRequest?: PatchedInvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoicesPartialUpdate(id, patchedInvoiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceApi.invoicesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invoicesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoicesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceApi.invoicesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invoicesServiceInvoiceRetrieve(serviceId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoicesServiceInvoiceRetrieve(serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceApi.invoicesServiceInvoiceRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {InvoiceRequest} invoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invoicesUpdate(id: number, invoiceRequest: InvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoicesUpdate(id, invoiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceApi.invoicesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvoiceApi - factory interface
 * @export
 */
export const InvoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceApiFp(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesInvoicesList(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Invoice>> {
            return localVarFp.invoicesInvoicesList(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Invoice>> {
            return localVarFp.invoicesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedInvoiceRequest} [patchedInvoiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesPartialUpdate(id: number, patchedInvoiceRequest?: PatchedInvoiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Invoice> {
            return localVarFp.invoicesPartialUpdate(id, patchedInvoiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Invoice> {
            return localVarFp.invoicesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesServiceInvoiceRetrieve(serviceId: number, options?: RawAxiosRequestConfig): AxiosPromise<Invoice> {
            return localVarFp.invoicesServiceInvoiceRetrieve(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {InvoiceRequest} invoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesUpdate(id: number, invoiceRequest: InvoiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Invoice> {
            return localVarFp.invoicesUpdate(id, invoiceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceApi - object-oriented interface
 * @export
 * @class InvoiceApi
 * @extends {BaseAPI}
 */
export class InvoiceApi extends BaseAPI {
    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoicesInvoicesList(userId: number, options?: RawAxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).invoicesInvoicesList(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoicesList(options?: RawAxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).invoicesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {PatchedInvoiceRequest} [patchedInvoiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoicesPartialUpdate(id: number, patchedInvoiceRequest?: PatchedInvoiceRequest, options?: RawAxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).invoicesPartialUpdate(id, patchedInvoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoicesRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).invoicesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoicesServiceInvoiceRetrieve(serviceId: number, options?: RawAxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).invoicesServiceInvoiceRetrieve(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {InvoiceRequest} invoiceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoicesUpdate(id: number, invoiceRequest: InvoiceRequest, options?: RawAxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).invoicesUpdate(id, invoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesPendingList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invoices/pending/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invoicesPendingList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoicesPendingList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.invoicesPendingList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesPendingList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Invoice>> {
            return localVarFp.invoicesPendingList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoicesPendingList(options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).invoicesPendingList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManagerApi - axios parameter creator
 * @export
 */
export const ManagerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ManagerRequest} managerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManagerCreateCreate: async (managerRequest: ManagerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'managerRequest' is not null or undefined
            assertParamExists('usersManagerCreateCreate', 'managerRequest', managerRequest)
            const localVarPath = `/api/users/manager/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(managerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this manager.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManagerDestroy: async (user: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersManagerDestroy', 'user', user)
            const localVarPath = `/api/users/manager/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this manager.
         * @param {PatchedManagerRequest} [patchedManagerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManagerPartialUpdate: async (user: number, patchedManagerRequest?: PatchedManagerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersManagerPartialUpdate', 'user', user)
            const localVarPath = `/api/users/manager/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(patchedManagerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this manager.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManagerRetrieve: async (user: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersManagerRetrieve', 'user', user)
            const localVarPath = `/api/users/manager/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this manager.
         * @param {ManagerRequest} managerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManagerUpdate: async (user: number, managerRequest: ManagerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersManagerUpdate', 'user', user)
            // verify required parameter 'managerRequest' is not null or undefined
            assertParamExists('usersManagerUpdate', 'managerRequest', managerRequest)
            const localVarPath = `/api/users/manager/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(managerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManagersList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/managers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagerApi - functional programming interface
 * @export
 */
export const ManagerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ManagerRequest} managerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersManagerCreateCreate(managerRequest: ManagerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manager>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersManagerCreateCreate(managerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagerApi.usersManagerCreateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} user A unique value identifying this manager.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersManagerDestroy(user: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersManagerDestroy(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagerApi.usersManagerDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} user A unique value identifying this manager.
         * @param {PatchedManagerRequest} [patchedManagerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersManagerPartialUpdate(user: number, patchedManagerRequest?: PatchedManagerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manager>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersManagerPartialUpdate(user, patchedManagerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagerApi.usersManagerPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} user A unique value identifying this manager.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersManagerRetrieve(user: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manager>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersManagerRetrieve(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagerApi.usersManagerRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} user A unique value identifying this manager.
         * @param {ManagerRequest} managerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersManagerUpdate(user: number, managerRequest: ManagerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manager>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersManagerUpdate(user, managerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagerApi.usersManagerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersManagersList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Manager>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersManagersList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagerApi.usersManagersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManagerApi - factory interface
 * @export
 */
export const ManagerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagerApiFp(configuration)
    return {
        /**
         * 
         * @param {ManagerRequest} managerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManagerCreateCreate(managerRequest: ManagerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Manager> {
            return localVarFp.usersManagerCreateCreate(managerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this manager.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManagerDestroy(user: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersManagerDestroy(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this manager.
         * @param {PatchedManagerRequest} [patchedManagerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManagerPartialUpdate(user: number, patchedManagerRequest?: PatchedManagerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Manager> {
            return localVarFp.usersManagerPartialUpdate(user, patchedManagerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this manager.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManagerRetrieve(user: number, options?: RawAxiosRequestConfig): AxiosPromise<Manager> {
            return localVarFp.usersManagerRetrieve(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this manager.
         * @param {ManagerRequest} managerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManagerUpdate(user: number, managerRequest: ManagerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Manager> {
            return localVarFp.usersManagerUpdate(user, managerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManagersList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Manager>> {
            return localVarFp.usersManagersList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManagerApi - object-oriented interface
 * @export
 * @class ManagerApi
 * @extends {BaseAPI}
 */
export class ManagerApi extends BaseAPI {
    /**
     * 
     * @param {ManagerRequest} managerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagerApi
     */
    public usersManagerCreateCreate(managerRequest: ManagerRequest, options?: RawAxiosRequestConfig) {
        return ManagerApiFp(this.configuration).usersManagerCreateCreate(managerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this manager.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagerApi
     */
    public usersManagerDestroy(user: number, options?: RawAxiosRequestConfig) {
        return ManagerApiFp(this.configuration).usersManagerDestroy(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this manager.
     * @param {PatchedManagerRequest} [patchedManagerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagerApi
     */
    public usersManagerPartialUpdate(user: number, patchedManagerRequest?: PatchedManagerRequest, options?: RawAxiosRequestConfig) {
        return ManagerApiFp(this.configuration).usersManagerPartialUpdate(user, patchedManagerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this manager.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagerApi
     */
    public usersManagerRetrieve(user: number, options?: RawAxiosRequestConfig) {
        return ManagerApiFp(this.configuration).usersManagerRetrieve(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this manager.
     * @param {ManagerRequest} managerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagerApi
     */
    public usersManagerUpdate(user: number, managerRequest: ManagerRequest, options?: RawAxiosRequestConfig) {
        return ManagerApiFp(this.configuration).usersManagerUpdate(user, managerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagerApi
     */
    public usersManagersList(options?: RawAxiosRequestConfig) {
        return ManagerApiFp(this.configuration).usersManagersList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MechanicApi - axios parameter creator
 * @export
 */
export const MechanicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MechanicRequest} mechanicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMechanicCreateCreate: async (mechanicRequest: MechanicRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mechanicRequest' is not null or undefined
            assertParamExists('usersMechanicCreateCreate', 'mechanicRequest', mechanicRequest)
            const localVarPath = `/api/users/mechanic/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(mechanicRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this mechanic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMechanicDestroy: async (user: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersMechanicDestroy', 'user', user)
            const localVarPath = `/api/users/mechanic/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this mechanic.
         * @param {PatchedMechanicRequest} [patchedMechanicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMechanicPartialUpdate: async (user: number, patchedMechanicRequest?: PatchedMechanicRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersMechanicPartialUpdate', 'user', user)
            const localVarPath = `/api/users/mechanic/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMechanicRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this mechanic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMechanicRetrieve: async (user: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersMechanicRetrieve', 'user', user)
            const localVarPath = `/api/users/mechanic/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this mechanic.
         * @param {MechanicRequest} mechanicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMechanicUpdate: async (user: number, mechanicRequest: MechanicRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersMechanicUpdate', 'user', user)
            // verify required parameter 'mechanicRequest' is not null or undefined
            assertParamExists('usersMechanicUpdate', 'mechanicRequest', mechanicRequest)
            const localVarPath = `/api/users/mechanic/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(mechanicRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMechanicsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/mechanics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MechanicApi - functional programming interface
 * @export
 */
export const MechanicApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = MechanicApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MechanicRequest} mechanicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMechanicCreateCreate(mechanicRequest: MechanicRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mechanic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMechanicCreateCreate(mechanicRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MechanicApi.usersMechanicCreateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} user A unique value identifying this mechanic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMechanicDestroy(user: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMechanicDestroy(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MechanicApi.usersMechanicDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} user A unique value identifying this mechanic.
         * @param {PatchedMechanicRequest} [patchedMechanicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMechanicPartialUpdate(user: number, patchedMechanicRequest?: PatchedMechanicRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mechanic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMechanicPartialUpdate(user, patchedMechanicRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MechanicApi.usersMechanicPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} user A unique value identifying this mechanic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMechanicRetrieve(user: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mechanic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMechanicRetrieve(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MechanicApi.usersMechanicRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} user A unique value identifying this mechanic.
         * @param {MechanicRequest} mechanicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMechanicUpdate(user: number, mechanicRequest: MechanicRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mechanic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMechanicUpdate(user, mechanicRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MechanicApi.usersMechanicUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMechanicsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Mechanic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMechanicsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MechanicApi.usersMechanicsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MechanicApi - factory interface
 * @export
 */
export const MechanicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MechanicApiFp(configuration)
    return {
        /**
         * 
         * @param {MechanicRequest} mechanicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMechanicCreateCreate(mechanicRequest: MechanicRequest, options?: RawAxiosRequestConfig): AxiosPromise<Mechanic> {
            return localVarFp.usersMechanicCreateCreate(mechanicRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this mechanic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMechanicDestroy(user: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersMechanicDestroy(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this mechanic.
         * @param {PatchedMechanicRequest} [patchedMechanicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMechanicPartialUpdate(user: number, patchedMechanicRequest?: PatchedMechanicRequest, options?: RawAxiosRequestConfig): AxiosPromise<Mechanic> {
            return localVarFp.usersMechanicPartialUpdate(user, patchedMechanicRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this mechanic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMechanicRetrieve(user: number, options?: RawAxiosRequestConfig): AxiosPromise<Mechanic> {
            return localVarFp.usersMechanicRetrieve(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this mechanic.
         * @param {MechanicRequest} mechanicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMechanicUpdate(user: number, mechanicRequest: MechanicRequest, options?: RawAxiosRequestConfig): AxiosPromise<Mechanic> {
            return localVarFp.usersMechanicUpdate(user, mechanicRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMechanicsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Mechanic>> {
            return localVarFp.usersMechanicsList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MechanicApi - object-oriented interface
 * @export
 * @class MechanicApi
 * @extends {BaseAPI}
 */
export class MechanicApi extends BaseAPI {
    /**
     * 
     * @param {MechanicRequest} mechanicRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MechanicApi
     */
    public usersMechanicCreateCreate(mechanicRequest: MechanicRequest, options?: RawAxiosRequestConfig) {
        return MechanicApiFp(this.configuration).usersMechanicCreateCreate(mechanicRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this mechanic.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MechanicApi
     */
    public usersMechanicDestroy(user: number, options?: RawAxiosRequestConfig) {
        return MechanicApiFp(this.configuration).usersMechanicDestroy(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this mechanic.
     * @param {PatchedMechanicRequest} [patchedMechanicRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MechanicApi
     */
    public usersMechanicPartialUpdate(user: number, patchedMechanicRequest?: PatchedMechanicRequest, options?: RawAxiosRequestConfig) {
        return MechanicApiFp(this.configuration).usersMechanicPartialUpdate(user, patchedMechanicRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this mechanic.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MechanicApi
     */
    public usersMechanicRetrieve(user: number, options?: RawAxiosRequestConfig) {
        return MechanicApiFp(this.configuration).usersMechanicRetrieve(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this mechanic.
     * @param {MechanicRequest} mechanicRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MechanicApi
     */
    public usersMechanicUpdate(user: number, mechanicRequest: MechanicRequest, options?: RawAxiosRequestConfig) {
        return MechanicApiFp(this.configuration).usersMechanicUpdate(user, mechanicRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MechanicApi
     */
    public usersMechanicsList(options?: RawAxiosRequestConfig) {
        return MechanicApiFp(this.configuration).usersMechanicsList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartApi - axios parameter creator
 * @export
 */
export const PartApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PartRequest} partRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partsAddCreate: async (partRequest: PartRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partRequest' is not null or undefined
            assertParamExists('partsAddCreate', 'partRequest', partRequest)
            const localVarPath = `/api/parts/add/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(partRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartApi - functional programming interface
 * @export
 */
export const PartApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PartApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PartRequest} partRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partsAddCreate(partRequest: PartRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Part>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partsAddCreate(partRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartApi.partsAddCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartApi - factory interface
 * @export
 */
export const PartApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartApiFp(configuration)
    return {
        /**
         * 
         * @param {PartRequest} partRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partsAddCreate(partRequest: PartRequest, options?: RawAxiosRequestConfig): AxiosPromise<Part> {
            return localVarFp.partsAddCreate(partRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartApi - object-oriented interface
 * @export
 * @class PartApi
 * @extends {BaseAPI}
 */
export class PartApi extends BaseAPI {
    /**
     * 
     * @param {PartRequest} partRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartApi
     */
    public partsAddCreate(partRequest: PartRequest, options?: RawAxiosRequestConfig) {
        return PartApiFp(this.configuration).partsAddCreate(partRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartsApi - axios parameter creator
 * @export
 */
export const PartsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partsListList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/parts/list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartsApi - functional programming interface
 * @export
 */
export const PartsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PartsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partsListList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Part>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partsListList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartsApi.partsListList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartsApi - factory interface
 * @export
 */
export const PartsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partsListList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Part>> {
            return localVarFp.partsListList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartsApi - object-oriented interface
 * @export
 * @class PartsApi
 * @extends {BaseAPI}
 */
export class PartsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartsApi
     */
    public partsListList(options?: RawAxiosRequestConfig) {
        return PartsApiFp(this.configuration).partsListList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuoteApi - axios parameter creator
 * @export
 */
export const QuoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {PatchedUpdateQuoteStatusRequest} [patchedUpdateQuoteStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesChangeStatusPartialUpdate: async (id: number, patchedUpdateQuoteStatusRequest?: PatchedUpdateQuoteStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotesChangeStatusPartialUpdate', 'id', id)
            const localVarPath = `/api/quotes/change_status/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUpdateQuoteStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateQuoteStatusRequest} [updateQuoteStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesChangeStatusUpdate: async (id: number, updateQuoteStatusRequest?: UpdateQuoteStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotesChangeStatusUpdate', 'id', id)
            const localVarPath = `/api/quotes/change_status/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateQuoteStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/quotes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteApi - functional programming interface
 * @export
 */
export const QuoteApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = QuoteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {PatchedUpdateQuoteStatusRequest} [patchedUpdateQuoteStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotesChangeStatusPartialUpdate(id: number, patchedUpdateQuoteStatusRequest?: PatchedUpdateQuoteStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateQuoteStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotesChangeStatusPartialUpdate(id, patchedUpdateQuoteStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuoteApi.quotesChangeStatusPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateQuoteStatusRequest} [updateQuoteStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotesChangeStatusUpdate(id: number, updateQuoteStatusRequest?: UpdateQuoteStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateQuoteStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotesChangeStatusUpdate(id, updateQuoteStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuoteApi.quotesChangeStatusUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quote>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuoteApi.quotesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuoteApi - factory interface
 * @export
 */
export const QuoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuoteApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {PatchedUpdateQuoteStatusRequest} [patchedUpdateQuoteStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesChangeStatusPartialUpdate(id: number, patchedUpdateQuoteStatusRequest?: PatchedUpdateQuoteStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateQuoteStatus> {
            return localVarFp.quotesChangeStatusPartialUpdate(id, patchedUpdateQuoteStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateQuoteStatusRequest} [updateQuoteStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesChangeStatusUpdate(id: number, updateQuoteStatusRequest?: UpdateQuoteStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateQuoteStatus> {
            return localVarFp.quotesChangeStatusUpdate(id, updateQuoteStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Quote>> {
            return localVarFp.quotesList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuoteApi - object-oriented interface
 * @export
 * @class QuoteApi
 * @extends {BaseAPI}
 */
export class QuoteApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {PatchedUpdateQuoteStatusRequest} [patchedUpdateQuoteStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public quotesChangeStatusPartialUpdate(id: number, patchedUpdateQuoteStatusRequest?: PatchedUpdateQuoteStatusRequest, options?: RawAxiosRequestConfig) {
        return QuoteApiFp(this.configuration).quotesChangeStatusPartialUpdate(id, patchedUpdateQuoteStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateQuoteStatusRequest} [updateQuoteStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public quotesChangeStatusUpdate(id: number, updateQuoteStatusRequest?: UpdateQuoteStatusRequest, options?: RawAxiosRequestConfig) {
        return QuoteApiFp(this.configuration).quotesChangeStatusUpdate(id, updateQuoteStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public quotesList(options?: RawAxiosRequestConfig) {
        return QuoteApiFp(this.configuration).quotesList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuotesApi - axios parameter creator
 * @export
 */
export const QuotesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesServiceRetrieve: async (serviceId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('quotesServiceRetrieve', 'serviceId', serviceId)
            const localVarPath = `/api/quotes/service/{service_id}/`
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuotesApi - functional programming interface
 * @export
 */
export const QuotesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = QuotesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotesServiceRetrieve(serviceId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotesServiceRetrieve(serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuotesApi.quotesServiceRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuotesApi - factory interface
 * @export
 */
export const QuotesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuotesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesServiceRetrieve(serviceId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.quotesServiceRetrieve(serviceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuotesApi - object-oriented interface
 * @export
 * @class QuotesApi
 * @extends {BaseAPI}
 */
export class QuotesApi extends BaseAPI {
    /**
     * 
     * @param {number} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotesApi
     */
    public quotesServiceRetrieve(serviceId: number, options?: RawAxiosRequestConfig) {
        return QuotesApiFp(this.configuration).quotesServiceRetrieve(serviceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {SchemaRetrieveFormatEnum} [format] 
         * @param {SchemaRetrieveLangEnum} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve: async (format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {SchemaRetrieveFormatEnum} [format] 
         * @param {SchemaRetrieveLangEnum} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaRetrieve(format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaRetrieve(format, lang, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemaApi.schemaRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {SchemaRetrieveFormatEnum} [format] 
         * @param {SchemaRetrieveLangEnum} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve(format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.schemaRetrieve(format, lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {SchemaRetrieveFormatEnum} [format] 
     * @param {SchemaRetrieveLangEnum} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaRetrieve(format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options?: RawAxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaRetrieve(format, lang, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SchemaRetrieveFormatEnum = {
    Json: 'json',
    Yaml: 'yaml'
} as const;
export type SchemaRetrieveFormatEnum = typeof SchemaRetrieveFormatEnum[keyof typeof SchemaRetrieveFormatEnum];
/**
 * @export
 */
export const SchemaRetrieveLangEnum = {
    Af: 'af',
    Ar: 'ar',
    ArDz: 'ar-dz',
    Ast: 'ast',
    Az: 'az',
    Be: 'be',
    Bg: 'bg',
    Bn: 'bn',
    Br: 'br',
    Bs: 'bs',
    Ca: 'ca',
    Ckb: 'ckb',
    Cs: 'cs',
    Cy: 'cy',
    Da: 'da',
    De: 'de',
    Dsb: 'dsb',
    El: 'el',
    En: 'en',
    EnAu: 'en-au',
    EnGb: 'en-gb',
    Eo: 'eo',
    Es: 'es',
    EsAr: 'es-ar',
    EsCo: 'es-co',
    EsMx: 'es-mx',
    EsNi: 'es-ni',
    EsVe: 'es-ve',
    Et: 'et',
    Eu: 'eu',
    Fa: 'fa',
    Fi: 'fi',
    Fr: 'fr',
    Fy: 'fy',
    Ga: 'ga',
    Gd: 'gd',
    Gl: 'gl',
    He: 'he',
    Hi: 'hi',
    Hr: 'hr',
    Hsb: 'hsb',
    Hu: 'hu',
    Hy: 'hy',
    Ia: 'ia',
    Id: 'id',
    Ig: 'ig',
    Io: 'io',
    Is: 'is',
    It: 'it',
    Ja: 'ja',
    Ka: 'ka',
    Kab: 'kab',
    Kk: 'kk',
    Km: 'km',
    Kn: 'kn',
    Ko: 'ko',
    Ky: 'ky',
    Lb: 'lb',
    Lt: 'lt',
    Lv: 'lv',
    Mk: 'mk',
    Ml: 'ml',
    Mn: 'mn',
    Mr: 'mr',
    Ms: 'ms',
    My: 'my',
    Nb: 'nb',
    Ne: 'ne',
    Nl: 'nl',
    Nn: 'nn',
    Os: 'os',
    Pa: 'pa',
    Pl: 'pl',
    Pt: 'pt',
    PtBr: 'pt-br',
    Ro: 'ro',
    Ru: 'ru',
    Sk: 'sk',
    Sl: 'sl',
    Sq: 'sq',
    Sr: 'sr',
    SrLatn: 'sr-latn',
    Sv: 'sv',
    Sw: 'sw',
    Ta: 'ta',
    Te: 'te',
    Tg: 'tg',
    Th: 'th',
    Tk: 'tk',
    Tr: 'tr',
    Tt: 'tt',
    Udm: 'udm',
    Ug: 'ug',
    Uk: 'uk',
    Ur: 'ur',
    Uz: 'uz',
    Vi: 'vi',
    ZhHans: 'zh-hans',
    ZhHant: 'zh-hant'
} as const;
export type SchemaRetrieveLangEnum = typeof SchemaRetrieveLangEnum[keyof typeof SchemaRetrieveLangEnum];


/**
 * ServiceApi - axios parameter creator
 * @export
 */
export const ServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateServiceRequest} createServiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAddCreate: async (createServiceRequest: CreateServiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createServiceRequest' is not null or undefined
            assertParamExists('servicesAddCreate', 'createServiceRequest', createServiceRequest)
            const localVarPath = `/api/services/add/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesChangeStatusPartialUpdate: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('servicesChangeStatusPartialUpdate', 'id', id)
            const localVarPath = `/api/services/change_status/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedServiceRequest} [patchedServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesEditPartialUpdate: async (id: number, patchedServiceRequest?: PatchedServiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('servicesEditPartialUpdate', 'id', id)
            const localVarPath = `/api/services/edit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(patchedServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {ServiceRequest} serviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesEditUpdate: async (id: number, serviceRequest: ServiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('servicesEditUpdate', 'id', id)
            // verify required parameter 'serviceRequest' is not null or undefined
            assertParamExists('servicesEditUpdate', 'serviceRequest', serviceRequest)
            const localVarPath = `/api/services/edit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(serviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesUserLatestServiceRetrieve: async (customerId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('servicesUserLatestServiceRetrieve', 'customerId', customerId)
            const localVarPath = `/api/services/user/{customer_id}/latest_service/`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceApi - functional programming interface
 * @export
 */
export const ServiceApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateServiceRequest} createServiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesAddCreate(createServiceRequest: CreateServiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesAddCreate(createServiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceApi.servicesAddCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesChangeStatusPartialUpdate(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesChangeStatusPartialUpdate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceApi.servicesChangeStatusPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedServiceRequest} [patchedServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesEditPartialUpdate(id: number, patchedServiceRequest?: PatchedServiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesEditPartialUpdate(id, patchedServiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceApi.servicesEditPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {ServiceRequest} serviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesEditUpdate(id: number, serviceRequest: ServiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesEditUpdate(id, serviceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceApi.servicesEditUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Service>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceApi.servicesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesUserLatestServiceRetrieve(customerId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesUserLatestServiceRetrieve(customerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceApi.servicesUserLatestServiceRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceApi - factory interface
 * @export
 */
export const ServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateServiceRequest} createServiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesAddCreate(createServiceRequest: CreateServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateService> {
            return localVarFp.servicesAddCreate(createServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesChangeStatusPartialUpdate(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.servicesChangeStatusPartialUpdate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedServiceRequest} [patchedServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesEditPartialUpdate(id: number, patchedServiceRequest?: PatchedServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Service> {
            return localVarFp.servicesEditPartialUpdate(id, patchedServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {ServiceRequest} serviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesEditUpdate(id: number, serviceRequest: ServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Service> {
            return localVarFp.servicesEditUpdate(id, serviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Service>> {
            return localVarFp.servicesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesUserLatestServiceRetrieve(customerId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.servicesUserLatestServiceRetrieve(customerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceApi - object-oriented interface
 * @export
 * @class ServiceApi
 * @extends {BaseAPI}
 */
export class ServiceApi extends BaseAPI {
    /**
     * 
     * @param {CreateServiceRequest} createServiceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public servicesAddCreate(createServiceRequest: CreateServiceRequest, options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).servicesAddCreate(createServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public servicesChangeStatusPartialUpdate(id: number, options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).servicesChangeStatusPartialUpdate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {PatchedServiceRequest} [patchedServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public servicesEditPartialUpdate(id: number, patchedServiceRequest?: PatchedServiceRequest, options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).servicesEditPartialUpdate(id, patchedServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {ServiceRequest} serviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public servicesEditUpdate(id: number, serviceRequest: ServiceRequest, options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).servicesEditUpdate(id, serviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public servicesList(options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).servicesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public servicesUserLatestServiceRetrieve(customerId: number, options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).servicesUserLatestServiceRetrieve(customerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceTypeApi - axios parameter creator
 * @export
 */
export const ServiceTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ServiceTypeRequest} serviceTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceTypesAddCreate: async (serviceTypeRequest: ServiceTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceTypeRequest' is not null or undefined
            assertParamExists('serviceTypesAddCreate', 'serviceTypeRequest', serviceTypeRequest)
            const localVarPath = `/api/service_types/add/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(serviceTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedServiceTypeRequest} [patchedServiceTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceTypesEditPartialUpdate: async (id: number, patchedServiceTypeRequest?: PatchedServiceTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serviceTypesEditPartialUpdate', 'id', id)
            const localVarPath = `/api/service_types/edit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(patchedServiceTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {ServiceTypeRequest} serviceTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceTypesEditUpdate: async (id: number, serviceTypeRequest: ServiceTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serviceTypesEditUpdate', 'id', id)
            // verify required parameter 'serviceTypeRequest' is not null or undefined
            assertParamExists('serviceTypesEditUpdate', 'serviceTypeRequest', serviceTypeRequest)
            const localVarPath = `/api/service_types/edit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(serviceTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceTypesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/service_types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceTypeApi - functional programming interface
 * @export
 */
export const ServiceTypeApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ServiceTypeRequest} serviceTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceTypesAddCreate(serviceTypeRequest: ServiceTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceTypesAddCreate(serviceTypeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceTypeApi.serviceTypesAddCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedServiceTypeRequest} [patchedServiceTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceTypesEditPartialUpdate(id: number, patchedServiceTypeRequest?: PatchedServiceTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceTypesEditPartialUpdate(id, patchedServiceTypeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceTypeApi.serviceTypesEditPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {ServiceTypeRequest} serviceTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceTypesEditUpdate(id: number, serviceTypeRequest: ServiceTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceTypesEditUpdate(id, serviceTypeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceTypeApi.serviceTypesEditUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceTypesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceTypesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceTypeApi.serviceTypesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceTypeApi - factory interface
 * @export
 */
export const ServiceTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceTypeApiFp(configuration)
    return {
        /**
         * 
         * @param {ServiceTypeRequest} serviceTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceTypesAddCreate(serviceTypeRequest: ServiceTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServiceType> {
            return localVarFp.serviceTypesAddCreate(serviceTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedServiceTypeRequest} [patchedServiceTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceTypesEditPartialUpdate(id: number, patchedServiceTypeRequest?: PatchedServiceTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServiceType> {
            return localVarFp.serviceTypesEditPartialUpdate(id, patchedServiceTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {ServiceTypeRequest} serviceTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceTypesEditUpdate(id: number, serviceTypeRequest: ServiceTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServiceType> {
            return localVarFp.serviceTypesEditUpdate(id, serviceTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceTypesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ServiceType>> {
            return localVarFp.serviceTypesList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceTypeApi - object-oriented interface
 * @export
 * @class ServiceTypeApi
 * @extends {BaseAPI}
 */
export class ServiceTypeApi extends BaseAPI {
    /**
     * 
     * @param {ServiceTypeRequest} serviceTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceTypeApi
     */
    public serviceTypesAddCreate(serviceTypeRequest: ServiceTypeRequest, options?: RawAxiosRequestConfig) {
        return ServiceTypeApiFp(this.configuration).serviceTypesAddCreate(serviceTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {PatchedServiceTypeRequest} [patchedServiceTypeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceTypeApi
     */
    public serviceTypesEditPartialUpdate(id: number, patchedServiceTypeRequest?: PatchedServiceTypeRequest, options?: RawAxiosRequestConfig) {
        return ServiceTypeApiFp(this.configuration).serviceTypesEditPartialUpdate(id, patchedServiceTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {ServiceTypeRequest} serviceTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceTypeApi
     */
    public serviceTypesEditUpdate(id: number, serviceTypeRequest: ServiceTypeRequest, options?: RawAxiosRequestConfig) {
        return ServiceTypeApiFp(this.configuration).serviceTypesEditUpdate(id, serviceTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceTypeApi
     */
    public serviceTypesList(options?: RawAxiosRequestConfig) {
        return ServiceTypeApiFp(this.configuration).serviceTypesList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SkillsSharingApi - axios parameter creator
 * @export
 */
export const SkillsSharingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: any; }} steps List of steps for the skill
         * @param {number} vehicleId ID of the predefined car
         * @param {string} vehiclePart Part of the vehicle
         * @param {SkillRequest} skillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingAddCreate: async (steps: { [key: string]: any; }, vehicleId: number, vehiclePart: string, skillRequest: SkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'steps' is not null or undefined
            assertParamExists('skillssharingAddCreate', 'steps', steps)
            // verify required parameter 'vehicleId' is not null or undefined
            assertParamExists('skillssharingAddCreate', 'vehicleId', vehicleId)
            // verify required parameter 'vehiclePart' is not null or undefined
            assertParamExists('skillssharingAddCreate', 'vehiclePart', vehiclePart)
            // verify required parameter 'skillRequest' is not null or undefined
            assertParamExists('skillssharingAddCreate', 'skillRequest', skillRequest)
            const localVarPath = `/api/skillssharing/add/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (steps !== undefined) {
                for (const [key, value] of Object.entries(steps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (vehicleId !== undefined) {
                localVarQueryParameter['vehicle_id'] = vehicleId;
            }

            if (vehiclePart !== undefined) {
                localVarQueryParameter['vehicle_part'] = vehiclePart;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(skillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [vehicleId] Filter skills by vehicle ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingListList: async (vehicleId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/skillssharing/list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (vehicleId !== undefined) {
                localVarQueryParameter['vehicle_id'] = vehicleId;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingSkillDeleteDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillssharingSkillDeleteDestroy', 'id', id)
            const localVarPath = `/api/skillssharing/skill/{id}/delete/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedSkillRequest} [patchedSkillRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingSkillEditPartialUpdate: async (id: number, patchedSkillRequest?: PatchedSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillssharingSkillEditPartialUpdate', 'id', id)
            const localVarPath = `/api/skillssharing/skill/{id}/edit/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {SkillRequest} skillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingSkillEditUpdate: async (id: number, skillRequest: SkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillssharingSkillEditUpdate', 'id', id)
            // verify required parameter 'skillRequest' is not null or undefined
            assertParamExists('skillssharingSkillEditUpdate', 'skillRequest', skillRequest)
            const localVarPath = `/api/skillssharing/skill/{id}/edit/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(skillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingSkillRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillssharingSkillRetrieve', 'id', id)
            const localVarPath = `/api/skillssharing/skill/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} vehicleId 
         * @param {number} vehicleId2 ID of the vehicle to get skills for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingVehicleSkillsList: async (vehicleId: number, vehicleId2: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleId' is not null or undefined
            assertParamExists('skillssharingVehicleSkillsList', 'vehicleId', vehicleId)
            // verify required parameter 'vehicleId2' is not null or undefined
            assertParamExists('skillssharingVehicleSkillsList', 'vehicleId2', vehicleId2)
            const localVarPath = `/api/skillssharing/vehicle/{vehicle_id}/skills/`
                .replace(`{${"vehicle_id"}}`, encodeURIComponent(String(vehicleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (vehicleId2 !== undefined) {
                localVarQueryParameter['vehicle_id'] = vehicleId2;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkillsSharingApi - functional programming interface
 * @export
 */
export const SkillsSharingApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SkillsSharingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {{ [key: string]: any; }} steps List of steps for the skill
         * @param {number} vehicleId ID of the predefined car
         * @param {string} vehiclePart Part of the vehicle
         * @param {SkillRequest} skillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillssharingAddCreate(steps: { [key: string]: any; }, vehicleId: number, vehiclePart: string, skillRequest: SkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Skill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillssharingAddCreate(steps, vehicleId, vehiclePart, skillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsSharingApi.skillssharingAddCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [vehicleId] Filter skills by vehicle ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillssharingListList(vehicleId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Skill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillssharingListList(vehicleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsSharingApi.skillssharingListList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillssharingSkillDeleteDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillssharingSkillDeleteDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsSharingApi.skillssharingSkillDeleteDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedSkillRequest} [patchedSkillRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillssharingSkillEditPartialUpdate(id: number, patchedSkillRequest?: PatchedSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Skill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillssharingSkillEditPartialUpdate(id, patchedSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsSharingApi.skillssharingSkillEditPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {SkillRequest} skillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillssharingSkillEditUpdate(id: number, skillRequest: SkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Skill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillssharingSkillEditUpdate(id, skillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsSharingApi.skillssharingSkillEditUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillssharingSkillRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Skill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillssharingSkillRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsSharingApi.skillssharingSkillRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} vehicleId 
         * @param {number} vehicleId2 ID of the vehicle to get skills for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillssharingVehicleSkillsList(vehicleId: number, vehicleId2: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Skill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillssharingVehicleSkillsList(vehicleId, vehicleId2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsSharingApi.skillssharingVehicleSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SkillsSharingApi - factory interface
 * @export
 */
export const SkillsSharingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SkillsSharingApiFp(configuration)
    return {
        /**
         * 
         * @param {{ [key: string]: any; }} steps List of steps for the skill
         * @param {number} vehicleId ID of the predefined car
         * @param {string} vehiclePart Part of the vehicle
         * @param {SkillRequest} skillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingAddCreate(steps: { [key: string]: any; }, vehicleId: number, vehiclePart: string, skillRequest: SkillRequest, options?: RawAxiosRequestConfig): AxiosPromise<Skill> {
            return localVarFp.skillssharingAddCreate(steps, vehicleId, vehiclePart, skillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [vehicleId] Filter skills by vehicle ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingListList(vehicleId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Skill>> {
            return localVarFp.skillssharingListList(vehicleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingSkillDeleteDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.skillssharingSkillDeleteDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedSkillRequest} [patchedSkillRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingSkillEditPartialUpdate(id: number, patchedSkillRequest?: PatchedSkillRequest, options?: RawAxiosRequestConfig): AxiosPromise<Skill> {
            return localVarFp.skillssharingSkillEditPartialUpdate(id, patchedSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {SkillRequest} skillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingSkillEditUpdate(id: number, skillRequest: SkillRequest, options?: RawAxiosRequestConfig): AxiosPromise<Skill> {
            return localVarFp.skillssharingSkillEditUpdate(id, skillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingSkillRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Skill> {
            return localVarFp.skillssharingSkillRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} vehicleId 
         * @param {number} vehicleId2 ID of the vehicle to get skills for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillssharingVehicleSkillsList(vehicleId: number, vehicleId2: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Skill>> {
            return localVarFp.skillssharingVehicleSkillsList(vehicleId, vehicleId2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SkillsSharingApi - object-oriented interface
 * @export
 * @class SkillsSharingApi
 * @extends {BaseAPI}
 */
export class SkillsSharingApi extends BaseAPI {
    /**
     * 
     * @param {{ [key: string]: any; }} steps List of steps for the skill
     * @param {number} vehicleId ID of the predefined car
     * @param {string} vehiclePart Part of the vehicle
     * @param {SkillRequest} skillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsSharingApi
     */
    public skillssharingAddCreate(steps: { [key: string]: any; }, vehicleId: number, vehiclePart: string, skillRequest: SkillRequest, options?: RawAxiosRequestConfig) {
        return SkillsSharingApiFp(this.configuration).skillssharingAddCreate(steps, vehicleId, vehiclePart, skillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [vehicleId] Filter skills by vehicle ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsSharingApi
     */
    public skillssharingListList(vehicleId?: number, options?: RawAxiosRequestConfig) {
        return SkillsSharingApiFp(this.configuration).skillssharingListList(vehicleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsSharingApi
     */
    public skillssharingSkillDeleteDestroy(id: number, options?: RawAxiosRequestConfig) {
        return SkillsSharingApiFp(this.configuration).skillssharingSkillDeleteDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {PatchedSkillRequest} [patchedSkillRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsSharingApi
     */
    public skillssharingSkillEditPartialUpdate(id: number, patchedSkillRequest?: PatchedSkillRequest, options?: RawAxiosRequestConfig) {
        return SkillsSharingApiFp(this.configuration).skillssharingSkillEditPartialUpdate(id, patchedSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {SkillRequest} skillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsSharingApi
     */
    public skillssharingSkillEditUpdate(id: number, skillRequest: SkillRequest, options?: RawAxiosRequestConfig) {
        return SkillsSharingApiFp(this.configuration).skillssharingSkillEditUpdate(id, skillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsSharingApi
     */
    public skillssharingSkillRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return SkillsSharingApiFp(this.configuration).skillssharingSkillRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} vehicleId 
     * @param {number} vehicleId2 ID of the vehicle to get skills for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsSharingApi
     */
    public skillssharingVehicleSkillsList(vehicleId: number, vehicleId2: number, options?: RawAxiosRequestConfig) {
        return SkillsSharingApiFp(this.configuration).skillssharingVehicleSkillsList(vehicleId, vehicleId2, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {PatchedTaskRequest} [patchedTaskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksEditPartialUpdate: async (id: number, patchedTaskRequest?: PatchedTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksEditPartialUpdate', 'id', id)
            const localVarPath = `/api/tasks/edit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {TaskRequest} taskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksEditUpdate: async (id: number, taskRequest: TaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksEditUpdate', 'id', id)
            // verify required parameter 'taskRequest' is not null or undefined
            assertParamExists('tasksEditUpdate', 'taskRequest', taskRequest)
            const localVarPath = `/api/tasks/edit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(taskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} mechanicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksMechanicList: async (mechanicId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mechanicId' is not null or undefined
            assertParamExists('tasksMechanicList', 'mechanicId', mechanicId)
            const localVarPath = `/api/tasks/mechanic/{mechanic_id}/`
                .replace(`{${"mechanic_id"}}`, encodeURIComponent(String(mechanicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksOutstandingList: async (serviceId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('tasksOutstandingList', 'serviceId', serviceId)
            const localVarPath = `/api/tasks/outstanding/{service_id}/`
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPendingList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/pending/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksServiceList: async (serviceId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('tasksServiceList', 'serviceId', serviceId)
            const localVarPath = `/api/tasks/service/{service_id}/`
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStatusPartialUpdate: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksStatusPartialUpdate', 'id', id)
            const localVarPath = `/api/tasks/{id}/status/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {PatchedTaskRequest} [patchedTaskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksEditPartialUpdate(id: number, patchedTaskRequest?: PatchedTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksEditPartialUpdate(id, patchedTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.tasksEditPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {TaskRequest} taskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksEditUpdate(id: number, taskRequest: TaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksEditUpdate(id, taskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.tasksEditUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.tasksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} mechanicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksMechanicList(mechanicId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksMechanicList(mechanicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.tasksMechanicList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksOutstandingList(serviceId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksOutstandingList(serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.tasksOutstandingList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksPendingList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksPendingList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.tasksPendingList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksServiceList(serviceId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksServiceList(serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.tasksServiceList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksStatusPartialUpdate(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksStatusPartialUpdate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.tasksStatusPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {PatchedTaskRequest} [patchedTaskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksEditPartialUpdate(id: number, patchedTaskRequest?: PatchedTaskRequest, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.tasksEditPartialUpdate(id, patchedTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {TaskRequest} taskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksEditUpdate(id: number, taskRequest: TaskRequest, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.tasksEditUpdate(id, taskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Task>> {
            return localVarFp.tasksList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} mechanicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksMechanicList(mechanicId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Task>> {
            return localVarFp.tasksMechanicList(mechanicId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksOutstandingList(serviceId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Task>> {
            return localVarFp.tasksOutstandingList(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPendingList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Task>> {
            return localVarFp.tasksPendingList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksServiceList(serviceId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Task>> {
            return localVarFp.tasksServiceList(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStatusPartialUpdate(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksStatusPartialUpdate(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {PatchedTaskRequest} [patchedTaskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public tasksEditPartialUpdate(id: number, patchedTaskRequest?: PatchedTaskRequest, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).tasksEditPartialUpdate(id, patchedTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {TaskRequest} taskRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public tasksEditUpdate(id: number, taskRequest: TaskRequest, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).tasksEditUpdate(id, taskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public tasksList(options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).tasksList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} mechanicId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public tasksMechanicList(mechanicId: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).tasksMechanicList(mechanicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public tasksOutstandingList(serviceId: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).tasksOutstandingList(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public tasksPendingList(options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).tasksPendingList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public tasksServiceList(serviceId: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).tasksServiceList(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public tasksStatusPartialUpdate(id: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).tasksStatusPartialUpdate(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersLoginCreate: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('usersLoginCreate', 'loginRequest', loginRequest)
            const localVarPath = `/api/users/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersLoginCreate(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Login>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersLoginCreate(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersLoginCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.usersList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersLoginCreate(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<Login> {
            return localVarFp.usersLoginCreate(loginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersList(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersLoginCreate(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersLoginCreate(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}